#
# Copyright (c) 2023 - Adjacent Link LLC, Bridgewater,
# New Jersey
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of Adjacent Link LLC nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#

from collections import defaultdict
import re

from lxml import etree
from pkg_resources import resource_filename

import otestpoint.toolkit.logger as Logger
from otestpoint.interface import Probe
from otestpoint.interface import ProbeException

from otestpoint.interface.measurementtable_pb2 import MeasurementTable
from otestpoint.emex.emanebroker import EmaneBroker,loadEmaneMeasurement
from otestpoint.emex.ostatisticbroker import OstatisticBroker
from otestpoint.emex.slotstatustallies import SlotStatusTallies
from otestpoint.emex.apiqueuemetrictallies import ApiQueueMetricTallies,RfSignalTallies


class ProbeBase(Probe):
    def __init__(self,name,plugin,moduleName,schemaFile):
        self._name = name
        self._plugin = plugin
        self._moduleName = moduleName
        self._schemaFile = schemaFile

        self._rxcache = SlotStatusTallies()
        self._txcache = SlotStatusTallies()
        self._apimetrics = ApiQueueMetricTallies()
        self._rfsignaltallies = defaultdict(lambda: RfSignalTallies())
        self._emane_broker = None
        self._ostatistic_broker = None

        self._controlport_sock = None
        self._ostatistic_sock = None
        self._have_ostatistic = False

    def build(self,probe):
        raise NotImplemented

    def loadTable(self,member,table,data):
        return None

    def initialize(self,configurationFile):
        self._logger.log(Logger.DEBUG_LEVEL,"/%s initialize configuration: %s" % (self._name,configurationFile))

        tree = etree.parse(configurationFile)

        root = tree.getroot()

        schemaDoc = etree.parse(resource_filename(self._moduleName,self._schemaFile))

        schema = etree.XMLSchema(etree=schemaDoc,attribute_defaults=True)

        if not schema(root):
            message = ""
            for entry in schema.error_log:
                message += "%d: %s " % (entry.line,entry.message)
            self._logger.log(Logger.ERROR_LEVEL,"/%s %s" % (self._name,message))
            raise ProbeException(message)

        self._address = root.get("address")
        self._controlport = int(root.get("controlport"))
        self._ostatisticport = int(root.get("ostatisticport"))
        nemId = root.get("nem")

        if nemId:
            nemId = int(nemId)

        self._logger.log(Logger.DEBUG_LEVEL,
                         "/%s initialize address %s controlport %d ostatisticport %d nem: %s" % (self._name,
                                                                                                 self._address,
                                                                                                 self._controlport,
                                                                                                 self._ostatisticport,
                                                                                                 nemId))

        self._probes = []
        self._tables = []
        self._table_builders = defaultdict(lambda: self.pass_through_table)
        self._table_builders['EMEX.Monitor.Tables.RadioModel'] = self.process_apiqueuemetrics_table
        self._table_builders['EMEX.Monitor.Tables.Receive'] = self.process_rfsignal_table

        names = []

        for probe_elem in root.xpath("//*/probes/*[@enable='yes']"):
            names.append(probe_elem.tag)

            normalize = probe_elem.tag.replace(".","_").lower()

            probe_name = f'Measurement_{normalize}'

            p = self.build(probe_name)

            match = re.match(".+\.Tables\..+",probe_elem.tag)

            if match:
                self._tables.append((probe_elem.tag,p))
            else:
                self._probes.append((probe_elem.tag,p))

            slot_table_type = probe_elem.attrib.get("slottabletype", None)

            if slot_table_type:
                if slot_table_type == 'slotstatus':
                    self._table_builders[probe_elem.tag] = self.slotstatus_slot_table
                elif slot_table_type == 'binsdelay':
                    self._table_builders[probe_elem.tag] = self.binsdelay_slot_table
                else:
                    # subframetimes is an ostatistic table
                    self._have_ostatistic = True
                    self._table_builders[probe_elem.tag] = self.subframetimes_slot_table

            self._logger.log(Logger.DEBUG_LEVEL,
                             f'probe_elem.tag={probe_elem.tag} ' \
                             f'slottabletype={slot_table_type} '
                             f'type(p)={type(p)}')

        self._emane_broker = EmaneBroker(self._name, nemId, self._logger)
        self._ostatistic_broker = OstatisticBroker(self._name, self._logger)

        return names


    def start(self):
        self._logger.log(Logger.DEBUG_LEVEL,"/%s start" % self._name)

        self._emane_broker.start(self._address, self._controlport)

        if self._have_ostatistic:
            self._ostatistic_broker.start(self._address, self._ostatisticport)


    def stop(self):
        self._logger.log(Logger.DEBUG_LEVEL,"/%s stop" % self._name )

        self._emane_broker.stop()

        if self._have_ostatistic:
            self._ostatistic_broker.stop()


    def destroy(self):
        self._logger.log(Logger.DEBUG_LEVEL,"/%s destroy" % self._name)


    def probe(self):
        self._logger.log(Logger.DEBUG_LEVEL,"/%s probe" % self._name)

        lstats = self._emane_broker.request_stats()

        ltables = self._emane_broker.request_tables()

        if self._have_ostatistic:
            ltables.update(self._ostatistic_broker.request_tables())

        self._logger.log(Logger.DEBUG_LEVEL,"/%s probe processing" % self._name)

        probeData = self.prepare_stats(lstats)

        probeData.extend(self.prepare_tables(lstats, ltables))

        return probeData


    def prepare_stats(self, lstats):
        probeData = []

        for name,probe in self._probes:
            probe.Clear()
            for member in sorted(probe.DESCRIPTOR.fields_by_name.keys()):
                if member != "description":
                    setattr(probe,member,lstats[member.replace('_','.')])

            probeData.append((name,
                              probe.SerializeToString(),
                              probe.description.name,
                              probe.description.module,
                              probe.description.version))

        return probeData


    def prepare_tables(self, lstats, ltables):
        probeData = []

        for key in ltables:
            self._logger.log(Logger.DEBUG_LEVEL,f'/{self._name} table={key}')

        for name,probe in self._tables:
            probe.Clear()

            self._table_builders[name](probe, lstats, ltables)

            probeData.append((name,
                              probe.SerializeToString(),
                              probe.description.name,
                              probe.description.module,
                              probe.description.version))
        return probeData


    def pass_through_table(self, probe, lstats, ltables):
        for member in sorted(probe.DESCRIPTOR.fields_by_name.keys()):
            if member != "description":
                table = getattr(probe,member)

                labels,rows = ltables[member.replace('_','.')]

                if not self.loadTable(member,table,rows):
                    for label in labels:
                        table.labels.append(label)

                    for row in rows:
                        r = table.rows.add()
                        for entry in row:
                            e = r.values.add()
                            loadEmaneMeasurement(e,*entry)


    def slotstatus_slot_table(self, probe, lstats, ltables):
        """
        Translate

           rxslotstatustable
           |Index|Frame|Slot|Valid|Missed|Idle|Tx|Long|Freq|Lock|.25|.50|.75|1.0|1.25|1.50|1.75|>1.75|
           |1    |0    |1   |30   |0     |0   |0 |0   |0   |0   |7  |23 |0  |0  |0   |0   |0   |0    |
           |2    |0    |2   |29   |0     |0   |0 |0   |0   |0   |5  |24 |0  |0  |0   |0   |0   |0    |
                ...

        and

           txslotstatustable
           |Index|Frame|Slot|Valid|Missed|Big|.25 |.50|.75|1.0|1.25|1.50|1.75|>1.75|
           |4    |0    |4   |1780 |0     |0  |1777|3  |0  |0  |0   |0   |0   |0    |
           |37   |0    |37  |1779 |0     |0  |1779|0  |0  |0  |0   |0   |0   |0    |
                ...

        to an overall totals for Tx and Rx

           |Type|.25 |.50|.75|1.0|>1.0|
           |RX  |12  |47 |0  |0  |0   |
           |TX  |3556|3  |0  |0  |0   |
        """
        rxslotmap = {
            10: '.25',
            11: '.50',
            12: '.75',
            13: '1.0',
            14: '>1.0',
            15: '>1.0',
            16: '>1.0',
            17: '>1.0',
        }
        self.process_slot_table(probe,
                                ltables,
                                'rxslotstatustable',
                                'RX',
                                rxslotmap,
                                self._rxcache)

        txslotmap = {
            6: '.25',
            7: '.50',
            8: '.75',
            8: '1.0',
            10: '>1.0',
            11: '>1.0',
            12: '>1.0',
            13: '>1.0',
        }
        self.process_slot_table(probe,
                                ltables,
                                'txslotstatustable',
                                'TX',
                                txslotmap,
                                self._txcache)


    def binsdelay_slot_table(self, probe, lstats, ltables):
        """
        Translate

           binsrxdelay
           | Type   | 0   | 1  | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | > |
           | ACK    | 0   | 0  | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
           | CTS    | 0   | 0  | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
                ...
           | ZTotal | 170 | 12 | 2 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |

        and

           binstxdelay
           | Type   | 0   | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | > |
           | ACK    | 0   | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
           | CTS    | 0   | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
                  ...
           | ZTotal | 287 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |

        to totals for Tx and Rx.

           |Type|.25 |.50|.75|1.0|>1.0|
           |RX  |12  |47 |0  |0  |0   |
           |TX  |3556|3  |0  |0  |0   |
        """
        slotmap = {
            1: '.25',
            2: '.25',
            3: '.50',
            4: '.50',
            5: '.50',
            6: '.75',
            7: '.75',
            8: '1.0',
            9: '1.0',
            10:'1.0',
            11: '>1.0',
        }
        self.process_slot_table(probe,
                                ltables,
                                'binsrxdelay',
                                'RX',
                                slotmap,
                                self._rxcache,
                                ['ZTotal'])

        self.process_slot_table(probe,
                                ltables,
                                'binstxdelay',
                                'TX',
                                slotmap,
                                self._txcache,
                                ['ZTotal'])


    def subframetimes_slot_table(self, probe, lstats, ltables):
        """
        Translate

           subframeprocesstimes
           |Subframe|0.25 |0.50|0.75|1.00|1.25|1.50|1.75|2.00|>2|NoiseProcBusy|NoiseProcDelay      |
           |0       |10287|2   |1   |0   |0   |1   |0   |0   |0 |1            |0.019690409096230824|
           |1       |10286|3   |1   |0   |0   |0   |0   |0   |1 |1            |0.019415217186012454|
           |2       |10289|0   |1   |0   |0   |0   |0   |1   |0 |1            |0.021247692155523044|
           |3       |10285|1   |0   |4   |1   |0   |0   |0   |0 |1            |0.02052482753514595 |
           |4       |10290|0   |0   |0   |0   |0   |1   |0   |0 |1            |0.0494011272482878  |
           |5       |10283|4   |1   |1   |2   |0   |0   |0   |0 |2            |0.019273054131329927|
           |6       |10290|0   |0   |0   |1   |0   |0   |0   |0 |1            |0.018503449623075905|
           |7       |10288|1   |1   |0   |0   |0   |0   |0   |0 |0            |0.01815238095467692 |
           |8       |10289|0   |0   |0   |0   |0   |0   |0   |0 |0            |0.02676139574378007 |
           |9       |10286|1   |1   |1   |0   |0   |0   |0   |0 |0            |0.030501700881257275|

        to totals for Tx and Rx.

           |Type|.25 |.50|.75|1.0|>1.0|
           |TXRX|3556|47 |0  |0  |0   |
        """
        slotmap = {
            1: '.25',
            2: '.50',
            3: '.75',
            4: '1.0',
            10: '>1.0'
        }
        self.process_slot_table(probe,
                                ltables,
                                'subframeprocesstimes',
                                'TXRX',
                                slotmap,
                                self._rxcache)


    def process_slot_table(self, probe, ltables, tablename, rowtype, slotmap, cache, rowfilter=[]):
        table = getattr(probe,'slottiminghistogram')

        if not table.labels:
            table.labels.append('Type')
            table.labels.append('.25')
            table.labels.append('.50')
            table.labels.append('.75')
            table.labels.append('1.0')
            table.labels.append('>1.0')

        tallies = cache.zero()

        labels,rows = ltables[tablename]
        for row in rows:
            if rowfilter and not row[0][0] in rowfilter:
                continue
            for i,entry in enumerate(row):
                if i in slotmap:
                    tallies[slotmap[i]] += entry[0]

        r = table.rows.add()

        e = r.values.add()

        e.type = MeasurementTable.Measurement.TYPE_STRING
        e.sValue = rowtype

        interval_tallies = cache.diff(tallies)

        cache.tallies = tallies

        for key in ('.25', '.50', '.75', '1.0', '>1.0'):
            e = r.values.add()

            e.type = MeasurementTable.Measurement.TYPE_UINTEGER

            e.uValue = interval_tallies[key]


    def process_apiqueuemetrics_table(self, probe, lstats, ltables):
        """
        <entry name="avgProcessAPIQueueDepth"     type="double"/>
        <entry name="avgProcessAPIQueueWait"      type="double"/>
        <entry name="avgTimedEventLatency"        type="double"/>
        <entry name="avgTimedEventLatencyRatio"   type="double"/>
        <entry name="numAPIQueued"                type="uint64"/>
        <entry name="processedConfiguration"      type="uint64"/>
        <entry name="processedDownstreamControl"  type="uint64"/>
        <entry name="processedDownstreamPackets"  type="uint64"/>
        <entry name="processedEvents"             type="uint64"/>
        <entry name="processedTimedEvents"        type="uint64"/>
        <entry name="processedUpstreamControl"    type="uint64"/>
        <entry name="processedUpstreamPackets"    type="uint64"/>
        """
        table = getattr(probe,'apiqueuemetrics')

        if not table.labels:
            # numQd: interval count of all queued events.
            table.labels.append('numQd')
            # avgQDepth: "backet-out" interval average of avgProcessAPIQueueDepth
            table.labels.append('avgQDepth')
            # numProcd: interval count of all processed/dequeued API queue events,
            # number of data points in the interval avgQWait. Interval
            # delta sum of:
	    #
            #    processedDownstreamPackets
            #    processedUpstreamPackets
            #    processedDownstreamControl
            #    processedUpstreamControl
            #    processedEvents
            #    processedConfiguration
            #    processedTimedEvents
            table.labels.append('numProcd')
            # avgQWait: "backed-out" interval average for avgProcessAPIQueueWait.
            table.labels.append('avgQWait')
            # numTimerEvents: interval count of processedTimedEvents. number of data ponits
            # in avgTimerLat and avgTimerLatRatio
            table.labels.append('numTimerEvents')
            # avgTimerLat: "backed-out" interval average of averageTimedEventLatency
            table.labels.append('avgTimerLat')
            # avgTimerLatRatio: "backed-out" interval average of averageTimedEventLatencyRadio
            table.labels.append('avgTimerLatRatio')

        r = table.rows.add()

        interval_vals = \
            self._apimetrics.update({
                'avgprocessapiqueuedepth': (lstats['numapiqueued'],
                                            lstats['avgprocessapiqueuedepth']),
                'avgprocessapiqueuewait': (lstats['processeddownstreampackets'] + \
                                           lstats['processedupstreampackets'] + \
                                           lstats['processeddownstreamcontrol'] + \
                                           lstats['processedupstreamcontrol'] + \
                                           lstats['processedevents'] + \
                                           lstats['processedconfiguration'] + \
                                           lstats['processedtimedevents'],
                                           lstats['avgprocessapiqueuewait']),
                'avgtimedeventlatency':(lstats['processedtimedevents'],
                                        lstats['avgtimedeventlatency']),
                'avgtimedeventlatencyratio':(lstats['processedtimedevents'],
                                             lstats['avgtimedeventlatencyratio'])
            })

        numapiqueued,avgprocessapiqueuedepth = interval_vals['avgprocessapiqueuedepth']
        e = r.values.add()
        e.type = MeasurementTable.Measurement.TYPE_UINTEGER
        e.uValue = numapiqueued
        e = r.values.add()
        e.type = MeasurementTable.Measurement.TYPE_DOUBLE
        e.dValue = avgprocessapiqueuedepth

        numapiprocessed,avgprocessapiqueuewait = interval_vals['avgprocessapiqueuewait']
        e = r.values.add()
        e.type = MeasurementTable.Measurement.TYPE_UINTEGER
        e.uValue = numapiprocessed
        e = r.values.add()
        e.type = MeasurementTable.Measurement.TYPE_DOUBLE
        e.dValue = avgprocessapiqueuewait

        processedtimedevents,avgtimedeventlatency = interval_vals['avgtimedeventlatency']
        e = r.values.add()
        e.type = MeasurementTable.Measurement.TYPE_UINTEGER
        e.uValue = processedtimedevents

        e = r.values.add()
        e.type = MeasurementTable.Measurement.TYPE_DOUBLE
        e.dValue = avgtimedeventlatency

        _,avgtimedeventlatencyratio = interval_vals['avgtimedeventlatencyratio']
        e = r.values.add()
        e.type = MeasurementTable.Measurement.TYPE_DOUBLE
        e.dValue = avgtimedeventlatencyratio


    def process_rfsignal_table(self, probe, lstats, ltables):
        """
        Compute interval averages for AvgRxPower, AvgNoiseFloor,
        AvgSINR and AvgINR

        [] rfsignaltable
        |NEM|AntennaId|FrequencyHz|NumSamples|AvgRxPower |AvgNoiseFloor|AvgSINR   |AvgINR      |
        |1  |0        |NA         |4702      |3.387052482|-106.02059991|109.407652|1.996157e-13|
        """
        table = getattr(probe,'rfsignaltable')

        labels,rows = ltables['rfsignaltable']

        if not table.labels:
            for label in labels:
                table.labels.append(label)

        for row in rows:
            nemid,antennaid,freqhz,numsamples,avgrxpower,avgnoisefloor,avgsinr,avginr = map(lambda x: x[0], row)

            interval_vals = \
                self._rfsignaltallies[(nemid,antennaid,freqhz)].update({
                    'avgrxpower':(numsamples, avgrxpower),
                    'avgnoisefloor':(numsamples,avgnoisefloor),
                    'avgsinr':(numsamples,avgsinr),
                    'avginr':(numsamples,avginr)
                })

            r = table.rows.add()

            e = r.values.add()
            e.type = MeasurementTable.Measurement.TYPE_UINTEGER
            e.uValue = nemid

            e = r.values.add()
            e.type = MeasurementTable.Measurement.TYPE_STRING
            e.sValue = str(antennaid)

            e = r.values.add()
            e.type = MeasurementTable.Measurement.TYPE_STRING
            e.sValue = str(freqhz)

            numsamples,avgrxpower = interval_vals['avgrxpower']
            e = r.values.add()
            e.type = MeasurementTable.Measurement.TYPE_UINTEGER
            e.uValue = numsamples
            e = r.values.add()
            e.type = MeasurementTable.Measurement.TYPE_DOUBLE
            e.dValue = avgrxpower

            _,avgnoisefloor = interval_vals['avgnoisefloor']
            e = r.values.add()
            e.type = MeasurementTable.Measurement.TYPE_DOUBLE
            e.dValue = avgnoisefloor

            _,avgsinr = interval_vals['avgsinr']
            e = r.values.add()
            e.type = MeasurementTable.Measurement.TYPE_DOUBLE
            e.dValue = avgsinr

            _,avginr = interval_vals['avginr']
            e = r.values.add()
            e.type = MeasurementTable.Measurement.TYPE_DOUBLE
            e.dValue = avginr
